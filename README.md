## Какой самый эффективный способ конкатенации строк?

1. Использование этого метода наиболее эффективно при объединении строк, так как Go конкатенирует их за один проход, без создания промежуточных строк.

```
strings.Join()
```

## Что такое интерфейсы, как они применяются в Go?

В Go интерфейсы используются для достижения полиморфизма, что позволяет объектам различных типов обращаться к методам с одинаковыми сигнатурами. Интерфейс в Go - это набор методов. Любой тип в Go автоматически удовлетворяет интерфейсу, если он реализует все его методы.

## Чем отличаются RWMutex от Mutex?

`Mutex` подходит для случаев, когда требуется эксклюзивный доступ к ресурсу(`Lock()` блокирует все остальные горутины, пытающиеся захватить этот Mutex, пока не будет выполнен `Unlock()`), в то время как `RWMutex` обеспечивает более гибкую систему блокировок, которая позволяет параллельное чтение и последовательную запись.

## Чем отличаются буферизированные и не буферизированные каналы?

В не буферизированных каналах операции чтения и записи блокируют выполнение горутин, пока другая горутина не готова выполнить соответствующую операцию. В буферизированных каналах операции записи могут быть неблокирующими, если буфер не заполнен.

## Какой размер у структуры struct{}{}?

Размер пустой структуры 0 байт, так как она не содержит никаких полей данных.

## Есть ли в Go перегрузка методов или операторов?

В настоящее время язык программирования Go не поддерживает перегрузку функций

## В какой последовательности будут выведены элементы map[int]int?

map не гарантирует определенного порядка элементов при итерации. Поэтому порядок, в котором элементы будут выведены при итерации по карте, не определен и может изменяться

## В чем разница make и new?

основное различие между make и new в языке Go заключается в том, что make используется для инициализации слайсов, карт и каналов, в то время как new используется для выделения памяти и создания экземпляров типов данных с возвращением указателя на новый экземпляр.

## Сколько существует способов задать переменную типа slice или map?

1

```
myMap := map[string]int{}
slice := []int{}
```

2

```
myMap := make(map[string]int)
slice := make([]int, 0)

```

3

```
var myMap map[string]int = map[string]int{}
var slice []int = []int{}
```

4

```
var myMap map[string]int = make(map[string]int)
var slice []int = make([]int, 0)
```

## Что выведет данная программа и почему?

```
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)//1
  update(p)
  fmt.Println(*p)//1
}
```

В данном примере внутри update изменяется сам указатель(который является копией оригинального указателя), а не не значение. на которое он указывает в функции main. Поэтому изменения внутри update локальны. Чтобы внутри update влиять на значение переменной a из main необходимо передать туда double pointer, т.е. указатель на указатель.

## Что выведет данная программа и почему?

```
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

Эта программа выведет числа от 0 до 4 в случайном порядке, а после произойдет deadlock, так горутины работают с копией sync.WaitGroup и не уменьшают счетчик оригинального WG, из-за чего main горутина будет в вечном ожидании их уменьшение счетчика до 0

## Что выведет данная программа и почему?

```
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n) // 0
}
```

вывод будет 0, потому что переменная n внутри блока if имеет область видимости только внутри этого блока, и она не изменяет значение переменной n, объявленной вне этого блока.

## Что выведет данная программа и почему?

```
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a) //[100 2 3 4 5]
}
```

При передаче среза в функцию копируется указатель на массив и длина. В функции изменяется 0 элемент первоначального массива, операция append создает новый массив, так как емкость предыдущего недостаточна и присвоит переменной v указатель на новый массив

## Что выведет данная программа и почему?

```
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice) // [b b a]
  }(slice)
  fmt.Print(slice) // [a a]
}
```

В анонимную функцию функцию передается копия указателя на массив и длина. При выполнении операции append создается новый массив, так как прошлый недостаточно велик для этого. Переменной slice присваивается указатель на новый массив, поэтому изменения 0 и 1 элемента внутри анонимной функции затрагивают новый созданный массив, а не первоначальный
